---
alwaysApply: false
---
# Cursor Database Skill

## Purpose
Specialized knowledge of Cursor IDE's internal SQLite database structure, including complete schemas, required field specifications, and best practices for database operations that maintain IDE compatibility.

## When to Use
- Working directly with Cursor's state.vscdb database
- Understanding complete chat and message data structures
- Ensuring API-created chats load properly in Cursor IDE
- Troubleshooting chat loading issues
- Implementing database write operations
- Validating bubble/composer structure completeness
- Repairing broken chats with incomplete fields

## Quick Start

### Database Location

**‚ö†Ô∏è CRITICAL: Two Different Storage Formats**

Cursor uses **two completely different database formats** depending on whether you're using the GUI IDE or the CLI agent:

#### 1. Cursor IDE Format (GUI)

Centralized SQLite database with all chats:

**macOS:**
```
~/Library/Application Support/Cursor/User/globalStorage/state.vscdb
```

**Linux:**
```
~/.config/Cursor/User/globalStorage/state.vscdb
```

**Windows:**
```
%APPDATA%\Cursor\User\globalStorage\state.vscdb
```

**Storage Pattern:**
- Single database file for all chats
- Uses `cursorDiskKV` table with key-value pattern
- Keys: `composerData:{chat_id}` and `bubbleId:{chat_id}:{bubble_id}`

#### 2. cursor-agent CLI Format (Headless)

**‚ö†Ô∏è COMPLETELY DIFFERENT:** cursor-agent CLI uses per-chat individual databases:

**Location Pattern:**
```
~/.cursor/chats/<user_hash>/<chat_id>/store.db
```

**Real Example:**
```
~/.cursor/chats/cb6534c3ffe71d2f16e8388bde280295/e2ae2741-6f1c-4df9-b396-cccfc6766a1d/store.db
```

**Storage Pattern:**
- Individual SQLite database per chat
- Separate directory structure with user hash
- Different schema than Cursor IDE (unknown schema at this time)
- Messages NOT stored in centralized `state.vscdb`

**Key Differences:**

| Feature | Cursor IDE | cursor-agent CLI |
|---------|-----------|------------------|
| Database per chat | No (one DB for all) | Yes (individual DB per chat) |
| Path pattern | `globalStorage/state.vscdb` | `~/.cursor/chats/<hash>/<chat_id>/` |
| Schema | Known (cursorDiskKV) | Unknown/Different |
| Discovery | Direct SQL query | Directory traversal |
| Key format | `composerData:`, `bubbleId:` | Unknown |

**Important for Remote Operations:**

When implementing remote chat functionality:
1. **Local Cursor IDE** (your machine) uses `state.vscdb`
2. **Remote cursor-agent** (headless machines) uses `~/.cursor/chats/` structure
3. Cannot directly query remote chat messages using Cursor IDE schema
4. Need different code path for reading cursor-agent format
5. Fallback to local DB if remote unavailable recommended

### Important: Workspace vs Global Storage

**‚ö†Ô∏è CRITICAL:** Cursor stores **ALL chat data** in `globalStorage/state.vscdb`, NOT in workspace-specific databases.

While Cursor creates workspace-specific databases at:
```
~/Library/Application Support/Cursor/User/workspaceStorage/{workspaceId}/state.vscdb
```

These workspace databases:
- ‚ùå Do NOT contain chat data (composerData or bubbleId entries)
- ‚úÖ May contain workspace-specific settings or state
- ‚úÖ Use the same schema but remain empty for chat purposes

**For chat operations, always use globalStorage/state.vscdb.**

See `rest/WORKSPACE_DATABASE_ANALYSIS.md` for detailed investigation results.

### Quick Access

#### For Cursor IDE (GUI) Databases

```bash
# Open Cursor IDE database
sqlite3 ~/Library/Application\ Support/Cursor/User/globalStorage/state.vscdb

# List all chats
SELECT key FROM cursorDiskKV WHERE key LIKE 'composerData:%';

# Get messages for a chat
SELECT key FROM cursorDiskKV WHERE key LIKE 'bubbleId:YOUR_CHAT_ID:%';
```

#### For cursor-agent CLI Databases

```bash
# Find all cursor-agent chats on a system
find ~/.cursor/chats -name "store.db" -type f

# List chat directories
ls -la ~/.cursor/chats/*/

# Access a specific chat's database
sqlite3 ~/.cursor/chats/<user_hash>/<chat_id>/store.db

# Example: Access chat e2ae2741...
sqlite3 ~/.cursor/chats/cb6534c3ffe71d2f16e8388bde280295/e2ae2741-6f1c-4df9-b396-cccfc6766a1d/store.db
```

**Note:** cursor-agent database schema is different from Cursor IDE. Use directory traversal to discover chats, not SQL queries.

## Database Schema

### Cursor IDE Schema (state.vscdb)

**Tables:**

**cursorDiskKV** - Main key-value store:
```sql
CREATE TABLE cursorDiskKV (
    key TEXT PRIMARY KEY,
    value BLOB
);
```

**ItemTable** - Active panel state:
```sql
CREATE TABLE ItemTable (
    key TEXT PRIMARY KEY,
    value TEXT
);
```

### Key Patterns in cursorDiskKV

```
composerData:{uuid}        -- Chat metadata (composer)
bubbleId:{composer}:{uuid} -- Individual messages (bubbles)
```

**Examples:**
```
composerData:3f1a6a8c-58d1-4fbe-81f7-1ad946d9c84e
bubbleId:3f1a6a8c-58d1-4fbe-81f7-1ad946d9c84e:7b2c8d9e-4f3a-11ec-9bbc-0242ac130002
```

### Value Storage

- Values stored as BLOB (binary)
- Content is JSON encoded as UTF-8
- Parse with: `json.loads(value_blob)`

### cursor-agent CLI Schema (store.db)

**‚úÖ SCHEMA DISCOVERED** (As of November 2024)

The cursor-agent CLI's `store.db` format has been reverse-engineered:

**Basic Info:**
- **Format:** SQLite 3.x database with WAL (Write-Ahead Logging)
- **Location:** `~/.cursor/chats/<user_hash>/<chat_id>/store.db`
- **Additional files:** `store.db-shm`, `store.db-wal` (WAL mode)
- **Typical size:** 4KB base + WAL file (can be 200KB+ with active changes)

**Tables:**

```sql
CREATE TABLE meta (
    key TEXT PRIMARY KEY,
    value TEXT              -- Hex-encoded JSON string
);

CREATE TABLE blobs (
    id TEXT PRIMARY KEY,    -- SHA-256 hash (64 hex characters)
    data BLOB               -- Binary data (protobuf format)
);
```

**Meta Table Structure:**

Stores chat metadata as hex-encoded JSON with single key "0":

```json
{
  "agentId": "chat-id-uuid",
  "latestRootBlobId": "sha256-hash-of-latest-state",
  "name": "Chat Name",
  "mode": "auto-run",
  "createdAt": 1763157138724
}
```

**Fields:**
- `agentId`: The chat UUID (matches directory name)
- `latestRootBlobId`: Pointer to most recent blob (content hash)
- `name`: Display name of the chat
- `mode`: Execution mode (`"auto-run"`, etc.)
- `createdAt`: Unix timestamp in milliseconds

**Blobs Table Structure:**

Stores conversation data as content-addressed blobs:

- **ID:** SHA-256 hash of the blob content (64 hex characters)
- **Data:** Binary protobuf-encoded message/state data
- **Size:** Varies from ~44 bytes to ~13KB per blob
- **Count:** Typically 10-20 blobs per chat

**Example Query:**
```bash
# Get chat metadata
sqlite3 store.db "SELECT key, value FROM meta" | \
  while IFS='|' read key value; do 
    echo "$value" | xxd -r -p
  done

# Count messages/blobs
sqlite3 store.db "SELECT COUNT(*) FROM blobs"

# List blob IDs
sqlite3 store.db "SELECT id, length(data) FROM blobs ORDER BY id"
```

**Implications for Remote Operations:**
1. ‚úÖ Schema is now known (meta + blobs tables)
2. ‚ö†Ô∏è Blob data is protobuf-encoded (not plain JSON)
3. ‚ö†Ô∏è Need protobuf parser to decode message contents
4. ‚úÖ Can read metadata easily (hex-decoded JSON)
5. ‚úÖ Can count messages (`SELECT COUNT(*) FROM blobs`)
6. ‚ö†Ô∏è Cannot extract full message text without protobuf schema
7. üí° Consider implementing fallback to local Cursor IDE DB

**Key Differences from Cursor IDE:**

| Feature | Cursor IDE | cursor-agent |
|---------|-----------|--------------|
| Storage | Centralized DB | Per-chat DB |
| Message format | JSON in BLOB | Protobuf in BLOB |
| Metadata | Embedded in composerData | Separate meta table |
| Message IDs | UUID-based | SHA-256 content hash |
| Decoding | Direct JSON parse | Requires protobuf |

**Discovery Pattern:**
```bash
# Find all cursor-agent chats
find ~/.cursor/chats -type d -mindepth 2 -maxdepth 2

# Example output:
# ~/.cursor/chats/cb6534c3ffe71d2f16e8388bde280295/e2ae2741-6f1c-4df9-b396-cccfc6766a1d
# ~/.cursor/chats/d42b9c57d24cf5db3bd8d332dc35437f/test-93E18D9C-F49F-47F8-85A9-795704BA25DD
```

**Chat ID Extraction:**
```bash
# Extract chat IDs from directory structure
find ~/.cursor/chats -type d -mindepth 2 -maxdepth 2 | \
  awk -F/ '{print $NF}'
```

**Quick Chat Info:**
```bash
# Get chat metadata for a specific chat
CHAT_ID="e2ae2741-6f1c-4df9-b396-cccfc6766a1d"
CHAT_DIR=$(find ~/.cursor/chats -type d -name "$CHAT_ID" | head -1)

# Extract metadata
sqlite3 "$CHAT_DIR/store.db" "SELECT value FROM meta WHERE key='0'" | \
  xxd -r -p | python3 -m json.tool

# Count messages
sqlite3 "$CHAT_DIR/store.db" "SELECT COUNT(*) as message_count FROM blobs"
```

## Complete Data Structures

### Chat (Composer) JSON

**Complete Structure** (Version 10):

```json
{
  "_v": 10,
  "composerId": "uuid",
  "name": "Chat title",
  "richText": "{\"root\":{\"children\":[{\"children\":[],\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1}],\"format\":\"\",\"indent\":0,\"type\":\"root\",\"version\":1}}",
  "hasLoaded": true,
  "text": "",
  "createdAt": 1731348502000,
  "lastUpdatedAt": 1731349142000,
  "isArchived": false,
  "isDraft": false,
  "totalLinesAdded": 86,
  "totalLinesRemoved": 1,
  "contextUsagePercent": 11.22,
  "fullConversationHeadersOnly": [
    {"bubbleId": "uuid", "type": 1}
  ]
}
```

**Critical Composer Fields:**

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `_v` | int | YES | Version number, must be 10 |
| `composerId` | string | YES | Chat UUID |
| `name` | string | YES | Chat title/name |
| `richText` | string | YES | Lexical editor JSON (as string) |
| `hasLoaded` | boolean | YES | Must be true for IDE to load |
| `text` | string | YES | Empty string "" |
| `createdAt` | int | YES | Unix timestamp (milliseconds) |
| `lastUpdatedAt` | int | YES | Unix timestamp (milliseconds) |
| `fullConversationHeadersOnly` | array | YES | List of {bubbleId, type} objects |

**Optional Composer Fields:**
- `isArchived`: boolean (default: false)
- `isDraft`: boolean (default: false)
- `totalLinesAdded`: int (default: 0)
- `totalLinesRemoved`: int (default: 0)
- `contextUsagePercent`: float (default: 0)

### Message (Bubble) JSON

**Complete Structure** (Version 3, 69+ fields):

```json
{
  "_v": 3,
  "type": 1,
  "bubbleId": "uuid",
  "text": "Message content",
  "createdAt": "2025-11-11T17:55:02.297Z",
  
  "requestId": "uuid",
  "checkpointId": "uuid",
  "richText": "{\"root\":{\"children\":[...]}}",
  
  "supportedTools": [1, 41, 7, 38, 8, 9, 11, 12, 15, 18, 19, 25, 27, 43, 46, 47, 29, 30, 32, 34, 35, 39, 40, 42, 44, 45],
  "tokenCount": {"inputTokens": 0, "outputTokens": 0},
  "context": {
    "composers": [], "quotes": [], "selectedCommits": [],
    "selectedPullRequests": [], "selectedImages": [], "folderSelections": [],
    "fileSelections": [], "terminalFiles": [], "selections": [],
    "terminalSelections": [], "selectedDocs": [], "externalLinks": [],
    "cursorRules": [], "cursorCommands": [], "uiElementSelections": [],
    "consoleLogs": [], "mentions": []
  },
  
  "isAgentic": true,
  "unifiedMode": 5,
  "toolFormerData": {},
  "thinking": {},
  
  "codeBlocks": [],
  "todos": [],
  
  "capabilityStatuses": {
    "mutate-request": [], "start-submit-chat": [], "before-submit-chat": [],
    "chat-stream-finished": [], "before-apply": [], "after-apply": [],
    "accept-all-edits": [], "composer-done": [], "process-stream": [],
    "add-pending-action": []
  },
  
  "approximateLintErrors": [],
  "lints": [],
  "codebaseContextChunks": [],
  "commits": [],
  "pullRequests": [],
  "attachedCodeChunks": [],
  "assistantSuggestedDiffs": [],
  "gitDiffs": [],
  "interpreterResults": [],
  "images": [],
  "attachedFolders": [],
  "attachedFoldersNew": [],
  "toolResults": [],
  "notepads": [],
  "capabilities": [],
  "multiFileLinterErrors": [],
  "diffHistories": [],
  "recentLocationsHistory": [],
  "recentlyViewedFiles": [],
  "fileDiffTrajectories": [],
  "docsReferences": [],
  "webReferences": [],
  "aiWebSearchResults": [],
  "attachedFoldersListDirResults": [],
  "humanChanges": [],
  "allThinkingBlocks": [],
  "attachedFileCodeChunksMetadataOnly": [],
  "capabilityContexts": [],
  "consoleLogs": [],
  "contextPieces": [],
  "cursorRules": [],
  "deletedFiles": [],
  "diffsForCompressingFiles": [],
  "diffsSinceLastApply": [],
  "documentationSelections": [],
  "editTrailContexts": [],
  "externalLinks": [],
  "knowledgeItems": [],
  "projectLayouts": [],
  "relevantFiles": [],
  "suggestedCodeBlocks": [],
  "summarizedComposers": [],
  "uiElementPicked": [],
  "userResponsesToSuggestedCodeBlocks": [],
  
  "existedSubsequentTerminalCommand": false,
  "existedPreviousTerminalCommand": false,
  "editToolSupportsSearchAndReplace": true,
  "isNudge": false,
  "isPlanExecution": false,
  "isQuickSearchQuery": false,
  "isRefunded": false,
  "skipRendering": false,
  "useWeb": false,
  
  "modelInfo": {"modelName": "claude-4.5-sonnet"}
}
```

### Critical Bubble Fields

**Core Fields (Always Required):**

| Field | Type | Description |
|-------|------|-------------|
| `_v` | int | Version number, must be 3 |
| `type` | int | 1=user message, 2=assistant message |
| `bubbleId` | string | Unique message UUID |
| `text` | string | Message text content |
| `createdAt` | string | ISO 8601 timestamp with Z suffix |

**Request Tracking (Required):**

| Field | Type | Description |
|-------|------|-------------|
| `requestId` | string | UUID for request tracking |
| `checkpointId` | string | UUID for checkpoint tracking |

**Rich Content (Required):**

| Field | Type | Description |
|-------|------|-------------|
| `richText` | string | Lexical editor JSON (as string) |
| `supportedTools` | array | List of 26 tool IDs |
| `tokenCount` | object | {inputTokens: int, outputTokens: int} |
| `context` | object | 17 selection context keys (all arrays) |

**State Flags (Required):**

| Field | Type | Description |
|-------|------|-------------|
| `isAgentic` | boolean | true for user, false for assistant |
| `unifiedMode` | int | Standard value: 5 |
| `editToolSupportsSearchAndReplace` | boolean | true |

**Capability System (Required):**

| Field | Type | Description |
|-------|------|-------------|
| `capabilityStatuses` | object | 10 capability types, each with array |
| `toolFormerData` | object | Tool call data (can be empty) |
| `thinking` | object | Reasoning data (can be empty) |

**Content Arrays (21+ Required, Can Be Empty):**

All these fields must exist, even if empty `[]`:
- `approximateLintErrors`, `lints`, `codebaseContextChunks`
- `commits`, `pullRequests`, `attachedCodeChunks`
- `assistantSuggestedDiffs`, `gitDiffs`, `interpreterResults`
- `images`, `attachedFolders`, `attachedFoldersNew`
- `toolResults`, `notepads`, `capabilities`
- `multiFileLinterErrors`, `diffHistories`
- `recentLocationsHistory`, `recentlyViewedFiles`
- `fileDiffTrajectories`, `docsReferences`
- `webReferences`, `aiWebSearchResults`
- `attachedFoldersListDirResults`, `humanChanges`
- `allThinkingBlocks`, `attachedFileCodeChunksMetadataOnly`
- `capabilityContexts`, `consoleLogs`, `contextPieces`
- `cursorRules`, `deletedFiles`, `diffsForCompressingFiles`
- `diffsSinceLastApply`, `documentationSelections`
- `editTrailContexts`, `externalLinks`, `knowledgeItems`
- `projectLayouts`, `relevantFiles`, `suggestedCodeBlocks`
- `summarizedComposers`, `codeBlocks`, `todos`
- `uiElementPicked`, `userResponsesToSuggestedCodeBlocks`

**Boolean Flags (7 Required):**
- `existedSubsequentTerminalCommand`: false
- `existedPreviousTerminalCommand`: false
- `editToolSupportsSearchAndReplace`: true
- `isNudge`: false
- `isPlanExecution`: false
- `isQuickSearchQuery`: false
- `isRefunded`: false
- `skipRendering`: false
- `useWeb`: false

**Assistant-Only Fields:**

| Field | Type | Required For | Description |
|-------|------|--------------|-------------|
| `modelInfo` | object | type=2 only | {modelName: string} |

### Field Count Requirements

**Why 69+ Fields Matter:**

Cursor IDE validates the complete bubble structure when loading chats. Missing fields cause:
- Silent loading failures (no error logs)
- Chat won't appear in chat list
- Chat appears but won't open
- IDE hangs when trying to load

**Field Count by Source:**

| Source | Typical Field Count | IDE Compatible? |
|--------|---------------------|-----------------|
| Minimal API bubble | 21-30 fields | ‚ùå NO |
| Partial API bubble | 40-50 fields | ‚ùå NO |
| Complete Cursor bubble | 69+ fields | ‚úÖ YES |

**Verification:**
```sql
-- Check field count in a bubble
SELECT 
  key,
  json_array_length(json_keys(value)) as field_count
FROM cursorDiskKV 
WHERE key LIKE 'bubbleId:%' 
LIMIT 1;
```

Should return 69 or more for IDE compatibility.

## Database Operations

### Read Operations

**Safe While Cursor Running:**
- SELECT queries
- Counting records
- Extracting schemas
- Analyzing structures

```bash
sqlite3 ~/Library/Application\ Support/Cursor/User/globalStorage/state.vscdb "
SELECT COUNT(*) FROM cursorDiskKV WHERE key LIKE 'composerData:%';
"
```

### Write Operations

**DANGER: Database Locking**

Writing while Cursor is running can cause:
- Database corruption
- Lost messages
- Cursor crash
- Data conflicts

**Safe Write Procedure:**
1. Close Cursor IDE completely
2. Backup database: `cp state.vscdb state.vscdb.backup`
3. Perform write operations
4. Verify writes: Check field counts and required fields
5. Reopen Cursor IDE

**Example Write:**
```python
import sqlite3
import json

conn = sqlite3.connect(db_path)
cursor = conn.cursor()

try:
    # Insert bubble
    cursor.execute(
        "INSERT INTO cursorDiskKV (key, value) VALUES (?, ?)",
        (f'bubbleId:{chat_id}:{bubble_id}', json.dumps(bubble_data))
    )
    conn.commit()
except Exception as e:
    conn.rollback()
    raise
finally:
    conn.close()
```

### Query Patterns

**List All Chats:**
```sql
SELECT key, value 
FROM cursorDiskKV 
WHERE key LIKE 'composerData:%'
ORDER BY json_extract(value, '$.lastUpdatedAt') DESC;
```

**Get Chat Metadata:**
```sql
SELECT value 
FROM cursorDiskKV 
WHERE key = 'composerData:YOUR_CHAT_ID';
```

**Get All Messages for Chat:**
```sql
SELECT key, value 
FROM cursorDiskKV 
WHERE key LIKE 'bubbleId:YOUR_CHAT_ID:%'
ORDER BY json_extract(value, '$.createdAt');
```

**Count Messages by Type:**
```sql
SELECT 
  json_extract(value, '$.type') as msg_type,
  COUNT(*) as count
FROM cursorDiskKV 
WHERE key LIKE 'bubbleId:YOUR_CHAT_ID:%'
GROUP BY msg_type;
```

**Find Incomplete Bubbles:**
```sql
SELECT 
  key,
  json_array_length(json_keys(value)) as field_count
FROM cursorDiskKV 
WHERE key LIKE 'bubbleId:%'
  AND json_array_length(json_keys(value)) < 69;
```

**Check for Missing composerData:**
```sql
-- Get bubbles without corresponding composer
SELECT DISTINCT 
  substr(key, 10, 36) as chat_id
FROM cursorDiskKV 
WHERE key LIKE 'bubbleId:%'
  AND 'composerData:' || substr(key, 10, 36) NOT IN (
    SELECT key FROM cursorDiskKV WHERE key LIKE 'composerData:%'
  );
```

## Best Practices for IDE Compatibility

### 8-Point Checklist

**Before Writing to Database:**

1. ‚úÖ **Complete Structure**: Include all 69+ fields
2. ‚úÖ **Proper Versions**: `_v: 3` for bubbles, `_v: 10` for composers
3. ‚úÖ **Unique IDs**: Generate fresh UUIDs for requestId/checkpointId
4. ‚úÖ **richText Format**: Valid Lexical editor JSON
5. ‚úÖ **All Arrays Present**: Even if empty, all 21+ arrays must exist
6. ‚úÖ **Boolean Flags**: All 7+ boolean flags with correct defaults
7. ‚úÖ **Type-Specific Fields**: modelInfo for assistant (type=2) messages
8. ‚úÖ **Composer Sync**: Update fullConversationHeadersOnly array

### Auto-Create Pattern

**Problem:** `cursor-agent create-chat` generates UUID but doesn't create database entry.

**Solution:** Auto-create composerData on first message if missing.

```python
def ensure_chat_exists(chat_id: str, cursor):
    """Create composerData entry if it doesn't exist."""
    cursor.execute(
        "SELECT value FROM cursorDiskKV WHERE key = ?",
        (f'composerData:{chat_id}',)
    )
    
    if not cursor.fetchone():
        # Create minimal composer metadata
        metadata = create_composer_metadata(chat_id)
        cursor.execute(
            "INSERT INTO cursorDiskKV (key, value) VALUES (?, ?)",
            (f'composerData:{chat_id}', json.dumps(metadata))
        )
        return True
    return False
```

**When to Use:**
- After calling `cursor-agent create-chat`
- Before sending first message to new chat
- In REST API endpoints that accept chat_id parameter
- After manual chat ID generation

## Remote Operations & cursor-agent Storage

### Challenge: Two Different Storage Systems

When building remote chat functionality (e.g., executing cursor-agent on remote machines), you encounter a critical mismatch:

**Local System (Web UI/IDE):**
- Runs Cursor IDE with GUI
- Uses `state.vscdb` centralized database
- All chats in one place
- Well-documented schema

**Remote Systems (Headless Execution):**
- Runs `cursor-agent` CLI only
- Uses `~/.cursor/chats/` per-chat structure
- Individual `store.db` per chat
- Unknown/undocumented schema

### Current Implementation Approaches

#### 1. Fallback Strategy (Implemented in blink-api)

When remote agent is unreachable or messages can't be fetched:

```rust
// Try to fetch from remote device
match remote_result {
    Ok(response) if response.status().is_success() => {
        // Use remote data
    }
    Ok(response) | Err(_) => {
        // Fall back to local Cursor IDE DB
        fetch_local_messages(&settings, &chat_id, &params, true)
    }
}
```

**Pros:**
- Always shows some data
- Graceful degradation
- Works offline

**Cons:**
- Not truly "remote" - shows local copy
- May be stale if remote has newer messages
- Requires chat to exist locally

#### 2. Direct Remote Query (Not Yet Implemented)

Read from remote cursor-agent's `store.db`:

```bash
# SSH to remote machine
ssh user@remote-host

# Find the chat
find ~/.cursor/chats -name "store.db" | \
  grep <chat_id>

# Query the database (schema TBD)
sqlite3 ~/.cursor/chats/.../store.db "SELECT ..."
```

**Pros:**
- True remote data
- Most up-to-date

**Cons:**
- Requires SSH access
- Schema unknown
- Performance overhead

#### 3. cursor-agent Export (Potential Future)

Use cursor-agent CLI to export messages:

```bash
# Hypothetical command (may not exist)
cursor-agent export-chat --chat-id <id> --format json
```

**Pros:**
- Clean abstraction
- Version-proof

**Cons:**
- Requires cursor-agent support
- May not be implemented

### Recommended Pattern for Remote Systems

For systems using remote cursor-agent:

1. **Track remote chats separately** in `remote_chats` table
2. **Attempt remote fetch** via HTTP endpoint to remote-agent-service
3. **Fallback to local DB** if remote unavailable
4. **Mark as fallback** in metadata (`location: "local_fallback"`)
5. **Implement discovery** by querying remote's `~/.cursor/chats` directory
6. **Cache remotely** if performance critical

**Example Database Schema:**
```sql
CREATE TABLE remote_chats (
    chat_id TEXT PRIMARY KEY,
    device_id TEXT NOT NULL,
    working_directory TEXT NOT NULL,
    name TEXT NOT NULL DEFAULT 'Untitled',
    created_at TEXT NOT NULL,
    last_updated_at TEXT,
    message_count INTEGER DEFAULT 0,
    last_message_preview TEXT
);
```

### Implementation Status (Updated November 2025)

**‚úÖ FULLY IMPLEMENTED:**

1. ‚úÖ cursor-agent schema discovered and documented
2. ‚úÖ Metadata reading (agentId, name, createdAt, etc.)
3. ‚úÖ Message counting and blob enumeration
4. ‚úÖ **Protobuf message extraction** - JSON embedded in blobs
5. ‚úÖ Full message text extraction working
6. ‚úÖ Local cursor-agent format reader implemented
7. ‚úÖ Remote cursor-agent format reader implemented
8. ‚úÖ Fallback mechanism: Remote ‚Üí Local cursor-agent ‚Üí Cursor IDE
9. ‚úÖ Confirmed format compatibility across macOS, Linux, remote systems
10. ‚úÖ End-to-end testing with context preservation verified

**Current Capabilities:**

The system now fully supports cursor-agent chats:
- `remote-agent-service/src/db.rs`: Reads from `~/.cursor/chats/<hash>/<chat_id>/store.db`
- `rest-rust/src/db/cursor_agent.rs`: Shared cursor-agent format reader
- `rest-rust/src/api/chats.rs`: Automatic format detection and fallback

**Key Discovery:**

Protobuf blobs contain JSON-encoded messages, not pure protobuf. The wrapper is minimal:
```rust
// Blob structure: [protobuf wrapper] + JSON message data
// JSON can be extracted by finding { ... } substring
// No full protobuf schema decoding needed
```

**Architecture:**
```
User Request ‚Üí blink-api
    ‚Üì
Is Remote Chat?
    ‚îú‚îÄ Yes ‚Üí Try Remote Agent
    ‚îÇ   ‚îú‚îÄ Success ‚Üí Return messages
    ‚îÇ   ‚îî‚îÄ Fail ‚Üí Fallback to Local
    ‚îÇ       ‚îú‚îÄ Try cursor-agent format
    ‚îÇ       ‚îî‚îÄ Try Cursor IDE format
    ‚îî‚îÄ No ‚Üí Local Chat
        ‚îú‚îÄ Try cursor-agent format
        ‚îî‚îÄ Try Cursor IDE format
```

See:
- `remote-agent-service/src/db.rs` - Remote cursor-agent reader
- `rest-rust/src/db/cursor_agent.rs` - Local cursor-agent reader
- `rest-rust/src/api/chats.rs` - Fallback orchestration

## cursor-agent Integration - End-to-End Testing ‚úì

### Implemented Features

As of November 2025, full cursor-agent storage format support has been implemented and tested:

**Storage Format Support:**
- ‚úì Read messages from `~/.cursor/chats/<user_hash>/<chat_id>/store.db`
- ‚úì Decode hex-encoded metadata from `meta` table
- ‚úì Extract JSON messages from protobuf-wrapped blobs
- ‚úì Support for user, assistant, and system message roles
- ‚úì Fallback mechanism: Remote ‚Üí Local cursor-agent ‚Üí Local Cursor IDE

**Message Extraction:**
- Blobs contain JSON-encoded messages wrapped in minimal protobuf
- JSON structure: `{"role": "user|assistant|system", "content": [...], "text": "..."}`
- User messages: content array with text objects
- Assistant messages: top-level `text` field
- Non-message blobs (state/metadata) are automatically skipped

### End-to-End Test Results

All tests performed on **November 14, 2025** with successful results:

#### Test 1: Basic Arithmetic with Context
```bash
Chat ID: 5159fd0e-552b-4e01-bf7d-20b0b9230e90
Message 1: "What is 2 + 2?" ‚Üí Response: "4"
Message 2: "And times 70?" ‚Üí Response: "280"
‚úì PASSED: Context preserved across messages
‚úì PASSED: blink-api correctly reads all messages
```

#### Test 2: String Manipulation
```bash
Chat ID: 29a5da87-fc91-49ec-ac7f-23df890bd570
Message 1: "What is 'hello' in uppercase?" ‚Üí Response: "HELLO"
Message 2: "Now add 'WORLD' to it" ‚Üí Response: "HELLO WORLD"
‚úì PASSED: String context preserved
```

#### Test 3: List Operations with Memory
```bash
Chat ID: 2ba4fecf-5cef-4662-9607-bc2cff01fa14
Message 1: "Give me 3 colors" ‚Üí Response: "1. Blue 2. Green 3. Red"
Message 2: "How many colors did you give me?" ‚Üí Response: "I gave you 3 colors"
‚úì PASSED: Agent correctly recalled previous response
```

#### Test 4: Multi-Turn Context Chain
```bash
Chat ID: 65e8c31d-eeef-465a-97b8-fd6e41f11175
Turn 1: "Set x = 5. What is x?" ‚Üí Response: "x is 5"
Turn 2: "What is x + 3?" ‚Üí Response: "x + 3 = 8"
Turn 3: "Now multiply that by 2" ‚Üí Response: "8 √ó 2 = 16"
‚úì PASSED: Complex multi-turn context preserved (5 ‚Üí 8 ‚Üí 16)
```

### Working with cursor-agent Chats

**Creating and Using Chats:**
```bash
# Create a new chat
CHAT_ID=$(cursor-agent create-chat)

# Send messages in headless mode
cursor-agent --print --resume "$CHAT_ID" "Your message here"

# Read messages via blink-api
curl "http://localhost:8067/chats/$CHAT_ID?include_metadata=true&include_content=true"
```

**Message Format in blink-api Response:**
```json
{
  "chat_id": "...",
  "message_count": 7,
  "messages": [
    {
      "blob_id": "...",
      "type": 1,
      "type_label": "user",
      "text": "Message content",
      "is_remote": false
    }
  ],
  "metadata": {
    "format": "cursor-agent",
    "location": "local",
    "name": "Chat name",
    "created_at": 1763171420000,
    "agent_id": "...",
    "mode": "auto-run"
  }
}
```

### Best Practices

1. **Context Preservation**: cursor-agent maintains context across messages in a chat session
2. **Headless Mode**: Use `--print` flag for non-interactive/scripting use
3. **Message Persistence**: Messages are immediately persisted to `store.db`
4. **Format Detection**: blink-api automatically detects and uses cursor-agent format
5. **Fallback Safety**: If remote is unavailable, local cursor-agent format is tried automatically

### Architecture

**Remote Agent Service:**
- `remote-agent-service/src/db.rs`: cursor-agent format reader
- Functions: `find_cursor_agent_chat()`, `get_chat_messages_from_agent()`, `get_chat_metadata_from_agent()`
- Endpoint: `GET /messages/:chat_id` returns JSON-decoded messages

**blink-api:**
- `rest-rust/src/db/cursor_agent.rs`: Local cursor-agent format reader (shared logic)
- `rest-rust/src/api/chats.rs`: Fallback mechanism (remote ‚Üí cursor-agent ‚Üí Cursor IDE)
- Automatic format detection and metadata marking

### Known Behaviors

- System messages (agent instructions) are included in message list
- Some blobs contain state/metadata and are skipped automatically
- Message order preserved by blob ID sorting
- Both formats (cursor-agent and Cursor IDE) coexist peacefully
- Context is preserved across multiple turns within a chat session

## Related Skills

- **cursor-internals** - For authentication, API, and cursor-agent CLI
- **blink-api-dev** - For REST API endpoint development
- **blink-debugging** - For troubleshooting full-stack issues

## Code Examples

See [EXAMPLES.mdc](EXAMPLES.mdc) for complete working code examples including:
- Creating complete 69+ field bubbles
- Writing to database safely
- Validating structures
- Repairing broken chats
- Complete workflow implementations
